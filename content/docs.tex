\section{Documentation}


\begin{frame}[fragile]{What You Will Learn:}
  \begin{itemize}
    \item Documenting your code using \emph{Sphinx}
    \item \emph{reStructuredText} (\reST/\texttt{RST}) syntax
    \item Using \emph{Read the Docs}
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{Why Should We Document Our Code?}
  Well-documented code improves\dots
  \begin{itemize}
    \item Maintainability: Future developers, debugging, \dots
    \item Accessibility: Make your package easier to understand for new users
    \item Collaboration: Docs as a shared knowledge source
  \end{itemize}
\end{frame}

\subsection{Sphinx}
\begin{frame}[fragile]{
  What is Sphinx?
  \hfill
  \doc{https://www.sphinx-doc.org}{Sphinx}}
  \begin{itemize}
    \setlength{\itemsep}{1em}
    \item Open-source, extensible documentation generator written in Python
    \item Multiple output formats: \texttt{HTML}, \LaTeX{} (for \texttt{PDF}), \texttt{ePub}, and more\dots
    \item Creates cross-references within your project and across different projects
    \item Allows documentation using a mark-up language (\reST)
    \item Supports various docstring formats (some through extensions)
  \end{itemize}

  \vspace{1cm}
  There are also alternatives to Sphinx, like \emph{MkDocs} and \emph{pdoc}, but Sphinx can be considered the industry standard for Python docs.
\end{frame}


\begin{frame}[fragile]{Installation}
  Sphinx can be installed via standard package managers:
  \begin{itemize}
    \setlength{\itemsep}{1em}
    \item Installing from PyPI using \texttt{pip}:
    \begin{minted}{shell-session}
      $ pip install -U sphinx
    \end{minted}
    \item Conda/Mamba:
    \begin{minted}{shell-session}
      $ mamba install sphinx
    \end{minted}
    \begin{minted}{shell-session}
      $ conda install -c conda-forge sphinx
    \end{minted}

    \item Debian/Ubuntu using \texttt{apt}:
    \begin{minted}{shell-session}
      # apt install python3-sphinx
    \end{minted}

  \item Fedora Linux, RHEL, CentOS using \texttt{yum} or \texttt{dnf}:
    \begin{minted}{shell-session}
      # yum install python-sphinx
      # dnf install python-sphinx
    \end{minted}

    \item Homebrew:
      \begin{minted}{shell-session}
        $ brew install sphinx-doc
      \end{minted}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Getting Started}
  \begin{minted}[escapeinside=||]{shell-session}
    $ sphinx-quickstart docs
    |\textcolor{cmauve}{> Separate source and build directories (y/n) [n]:}| y
    |\textcolor{cmauve}{> Project name:}| ...
    |\textcolor{cmauve}{> Author name(s):}| ...
    |\textcolor{cmauve}{> Project release []:}| ...
    |\textcolor{cmauve}{> Project language [en]:}| ...
  \end{minted}

  \forestset{
    textfile/.style = {
      execute at begin node=\textcolor{vertexDarkRed}{\faFile*}\space
    },
    batchfile/.style = {
      execute at begin node=\textcolor{vertexDarkRed}{\faTerminal}\space
    },
    makefile/.style = {
      execute at begin node=\textcolor{vertexDarkRed}{\faFile}\space
    },
    pythonfile/.style = {
      execute at begin node=\textcolor{vertexDarkRed}{\faPython}\space
    },
    opened/.style = {execute at begin node=\textcolor{dircolor}{\faFolderOpen}\space},
    closed/.style = {execute at begin node=\textcolor{dircolor}{\faFolder}\space},
    dir tree/.style = {
      grow'=0,
      font=\ttfamily,
      folder,
      fit=band,
      s sep=5pt,
      before computing xy={l=20pt},
      edge={rounded corners=2pt},
    }
  }

  \begin{center}
  \pause
  \begin{minipage}{.45\textwidth}
  \adjustbox{max height=5.5cm}{%
    \begin{forest}
      for tree={dir tree}
      [docs, opened
        [build, closed]
        [source, opened
          [\_static, closed]
          [\_templates, closed]
          [conf.py, pythonfile]
          [index.rst, textfile]
        ]
        [make.bat, batchfile]
        [Makefile, makefile]
      ]
    \end{forest}
  }
  \end{minipage}
  \hfill
  \pause
  \begin{minipage}{.45\textwidth}
    \adjustbox{max height=5.5cm}{%
      \begin{forest}
        for tree={dir tree}
        [docs, opened
          [\_build, closed]
          [\_static, closed]
          [\_templates, closed]
          [conf.py, pythonfile]
          [index.rst, textfile]
          [make.bat, batchfile]
          [Makefile, makefile]
        ]
      \end{forest}
    }
  \end{minipage}
  \end{center}
\end{frame}
{
\setbeamercolor{description item}{fg=vertexDarkGrey}
\begin{frame}[fragile]{Breakdown of the Generated Structure}
  \begin{description}[labelwidth=\widthof{\faFolderOpen \texttt{\_templates}}]
    \setlength{\itemindent}{-4em}
    \item [\textcolor{dircolor}{\faFolderOpen} \texttt{build}:] Output directory for the docs.
    \item [\textcolor{dircolor}{\faFolderOpen} \texttt{\_static}:] Directory for static elements such as images, icons, or logos.
    \item [\textcolor{dircolor}{\faFolderOpen} \texttt{\_templates}:] Used to store \href{https://jinja.palletsprojects.com/en/stable/}{\texttt{Jinja}}
      templates for HTML page generation. %Also used by some Sphinx extensions.
    \item [\textcolor{vertexDarkRed}{\faFile*} \texttt{index.rst}:] Root document; contains the root of the table of contents tree.
      % Effectively your landing page in the HTML version.
    \item [\textcolor{vertexDarkRed}{\faPython} \texttt{conf.py}:] Main configuration file written in Python.
  \end{description}
\end{frame}
}

\begin{frame}[fragile]{Let's Build Our Docs}
  We will use the \texttt{Makefile} generated by \mintinline{shell-session}+sphinx-quickstart+ to build any format:
  \begin{minted}{shell-session}
    $ make <format>
  \end{minted}
  So, for the HTML version:
  \begin{minted}{shell-session}
    $ make html
  \end{minted}
  This will generate the HTML files for our docs inside the \texttt{build} directory.
  We can view the docs locally by running a Python HTTP server (in this case from inside the \texttt{docs} directory):
  \begin{minted}{shell-session}
    $ python -m http.server -d build/html [port]
  \end{minted}

  \begin{block}{Note}
    \mintinline{shell-session}+[port]+ is optional, see \mintinline{shell-session}+python -m http.server --help+.
  \end{block}
\end{frame}


\begin{frame}[fragile]{Preview}
\end{frame}

\begin{frame}[fragile]{Setting Up \texttt{conf.py}}
  The \texttt{conf.py} file generated by Sphinx should look something like this:
  \begin{minted}{python}
    # -- Project information ------------------------
    project = 'pyopp'
    copyright = '2025, Author'
    author = 'Author'
    release = 'v0.1'

    # -- General configuration ----------------------
    extensions = []

    templates_path = ['_templates']
    exclude_patterns = []

    # -- Options for HTML output --------------------
    html_theme = 'alabaster'
    html_static_path = ['_static']
  \end{minted}
\end{frame}

\begin{frame}[fragile]{Setting Up \texttt{conf.py} | Project Information}
  When using a \texttt{pyproject.toml} file for our project, we automatically get the metadata
  from that file using \texttt{tomli} or \texttt{tomllib} (Python $\geqslant$ \texttt{3.11}):
  {
  \footnotesize
  \begin{minted}{python}
    #!/usr/bin/env python3
    import datetime
    import sys
    from pathlib import Path

    import pyvisgen

    if sys.version_info < (3, 11):
        import tomli as tomllib
    else:
        import tomllib

    pyproject_path = Path(__file__).parent.parent.parent / "pyproject.toml"
    pyproject = tomllib.loads(pyproject_path.read_text())

    project = pyproject["project"]["name"]
    author = pyproject["project"]["authors"][0]["name"]
    copyright = "{}.  Last updated {}".format(
        author, datetime.datetime.now().strftime("%d %b %Y %H:%M")
    )
    python_requires = pyproject["project"]["requires-python"]
  \end{minted}
  }
\end{frame}


\begin{frame}[fragile]{Setting Up \texttt{conf.py} | General Configuration}
  Sphinx extensions add functionality and customization. The following extensions
  are some of the extensions we always use in our docs:
  {
  \footnotesize
  \begin{minted}{python}
    extensions = [
        "sphinx.ext.autodoc",                 # Imports modules and pulls in documentation from docstrings
        "sphinx.ext.intersphinx",             # Cross-references to other projects
        "sphinx.ext.coverage",                # Collects doc coverage stats
        "sphinx.ext.viewcode",                # Links to highlighted source code (i.e. "[source]" button)
        "sphinx_automodapi.automodapi",                    # Automatically generates module documentation
        "sphinx_automodapi.smart_resolver",                # Helps resolving some imports
        "numpydoc",                                        # Support for the NumPy docstring format
        "IPython.sphinxext.ipython_console_highlighting",  # Syntax highlighting of ipython prompts
        "sphinx_copybutton",                               # Adds a copybutton to code blocks
    ]

    # gets rid of some errors during build
    numpydoc_show_class_members = False
    numpydoc_class_members_toctree = False

    intersphinx_mapping = {
       "numpy": ("https://numpy.org/doc/stable", None),
       ...
    }

    suppress_warnings = ["intersphinx.external"]  # sometimes necessary

    templates_path = ["_templates"]
    exclude_patterns = ["build", "Thumbs.db", ".DS_Store", "changes", "*.log"]

    source_suffix = ".rst"  # Set .rst files as source files for docs
    master_doc = "index"    # index.rst as root file
  \end{minted}
  }
\end{frame}


\begin{frame}[fragile]{Setting Up \texttt{conf.py} | General Configuration}
    Some extensions are external and need to be installed separately in your environment:
    \begin{minted}{shell-session}
      $ mamba install sphinx-automodapi numpydoc pydata-sphinx-theme sphinx-copybutton
    \end{minted}
    or with \texttt{pip}
    \begin{minted}{shell-session}
      $ pip install sphinx-automodapi numpydoc pydata-sphinx-theme sphinx-copybutton
    \end{minted}
\end{frame}


\begin{frame}[fragile]{Setting Up \texttt{conf.py} | HTML And Theme Options}
  HTML options set the look of your docs. The Sphinx community has created a variety of
  themes you can choose from.
  {
  \footnotesize
  \begin{minted}{python}
    html_theme = "pydata_sphinx_theme"            # Modern, widely used theme
    html_static_path = ["_static"]

    html_file_suffix = ".html"

    html_css_files = ["custom.css"]               # Custom CSS settings like colors or fonts

    html_favicon = "_static/favicon/favicon.ico"  # Icon file for browser tabs

    html_theme_options = {...}                    # Depends on the theme

    html_title = f"{project}"                     # e.g. your project name
    htmlhelp_basename = project + "docs"
  \end{minted}
  }
\end{frame}




\begin{frame}[fragile]{Filling the Docs With Some API References}
  We will create the API references (semi-)automatically in a few steps:
  \begin{columns}[t, onlytextwidth]
    \begin{column}{0.48\textwidth}
      \begin{enumerate}
        \item <1-> Copy the structure of your actual package
        \item <2-> Populate every subdirectory with a \texttt{index.rst}
        \item <3-> Create separate \texttt{.rst} files for every submodule
      \end{enumerate}
    \end{column}
  \end{columns}
\end{frame}


\begin{frame}[fragile]{Some reStructuredText (\texttt{reST}) Syntax}
  \begin{columns}[t, onlytextwidth]
    \begin{column}{0.33\textwidth}
      \begin{block}{Headings}
        \begin{minted}{rst}
          ====
          Part
          ====

          *******
          Chapter
          *******

          Section
          =======

          Subsection
          ----------

          Subsubsection
          ^^^^^^^^^^^^^

          Paragraph
          """""""""
        \end{minted}
      \end{block}
    \end{column}
    \hfill
    \begin{column}{0.66\textwidth}
      \begin{itemize}
        \setlength{\itemsep}{1em}
        \item The structure is technically determined by order of occurance
        \begin{itemize}
          \item \textbf{But}: For better readability stick to the same order throughout your docs, \eg, the one shown here
        \end{itemize}
        \item While overlines are optional, they are encouraged for parts and chapters
        \item Parts are also commonly set using \texttt{\#}
        \item Any of the following symbols are valid for over- and underlines:\\
          \textcolor{vertexDarkRed}{\texttt{=} \texttt{*} \texttt{-} \texttt{\textasciicircum} \texttt{"} \texttt{+} \texttt{\_} \texttt{\#} \texttt{\textasciitilde}}
          \mintinline{shell-session}{` . , : ; ' ! ? & $ %}
          \mintinline{shell-session}+( ) [ ] { }+\\
          \mintinline{shell-session}+< > @ \ / |+
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Docstrings}
\begin{frame}[fragile]{Docstrings}
  Most of the documentation work will require you to write docstrings. The three most common
  formats are:
  \begin{itemize}
    \item \reST
    \item Google
    \item \texttt{numpydoc}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Docstrings | \reST}
  \begin{block}{Structure}
    \footnotesize
    \begin{minted}{python}
      """[Summary of your method]

      :param [Parameter name]: [Parameter description]
      :type [Parameter name]: [Parameter type](, optional)
      :returns: [Return description]
      :rtype: [Return type]
      :raises [Exception class]: [Exception description]
      """
    \end{minted}
  \end{block}
  \begin{block}{Example}
    \footnotesize
    \begin{minted}{python}
      """This is a reST-style docstring.

      :param param1: First parameter.
      :type param1: float
      :param param2: Second parameter, defaults to None.
      :type param2: str, optional
      :returns: Some return value.
      :rtype: int
      :raises ValueError: Raises an exception.
      """
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Docstrings | Google}
  \begin{block}{Structure}
    \footnotesize
      \begin{minted}{python}
        """[Summary of your method]

        Args:
            [Parameter name] ([Parameter type](, optional)): [Parameter description]

        Returns:
            [Return type]: [Return description]

        Raises:
            [Exception class]: [Exception description]
        """
      \end{minted}
    \end{block}
    \begin{block}{Example}
    \footnotesize
      \begin{minted}{python}
        """This is a Google-style docstring.

        Args:
            param1 (float): First parameter.
            param2 (:obj:`str`, optional): Second parameter. Defaults to None.

        Returns:
            int: Some return value.

        Raises:
            ValueError: Raises an exception.
        """
      \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Docstrings | \texttt{numpydoc}}
  \begin{CodeExplanation}{0.59}[Structure][Example]
    \footnotesize
    \begin{minted}{python}
      """[Summary of your method]

      Parameters
      ----------
      [Parameter name] : [Parameter type](, optional)
          [Parameter description]

      Returns
      -------
      [Return name or type]( : [Return type if name was given])
          [Return description]

      Raises
      ------
      [Exception class]
          [Exception description]
      """
    \end{minted}
    \Explanation
    \footnotesize
    \begin{minted}{python}
      """This is a numpydoc-style docstring.

      Parameters
      ----------
      param1 : float
          First parameter.
      param2 : str, optional
          Second parameter. Default: None

      Returns
      -------
      int
          Some return value.

      Raises
      ------
      ValueError
          Raises an exception.
      """
    \end{minted}
  \end{CodeExplanation}
\end{frame}

\begin{frame}[fragile]{
    Type Hinting
    \hfill
    \doc{https://docs.python.org/3/library/typing.html}{\texttt{typing}}
  }
  \begin{itemize}
    \setlength{\itemsep}{1.5em}
    \item Type hinting is the practice of declaring types for variables using a colon \texttt{:}
  after the variable name:
  \begin{minted}{python}
    foo: int = 1
    bar: str = "pyopp"
    baz: np.ndarray = np.array([...])
  \end{minted}

  \item Usually, type hinting is only applied to function definitions:
  \begin{minted}{python}
    def func(param1: int, param2: int=42) -> int:
        res = param1 + param2
        return res
  \end{minted}

  \item Type hinting offers\dots
  \begin{itemize}
    \item Improved code readability
    \item IDE and linting support, \eg{}, through code completion
  \end{itemize}
  But: It is \textbf{not} enforced at runtime and one has to consider dynamic types.
  \end{itemize}
\end{frame}
