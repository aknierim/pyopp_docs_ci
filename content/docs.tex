\section{Documentation}


\begin{frame}[fragile]{What You Will Learn:}
  \begin{itemize}
    \item Documenting your code using \emph{Sphinx}
    \item \emph{reStructuredText} (\reST/\texttt{RST}) syntax
    \item Using \emph{Read the Docs}
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{Why Should We Document Our Code?}
  Well-documented code improves\dots
  \begin{itemize}
    \item Maintainability: Future developers, debugging, \dots
    \item Accessibility: Make your package easier to understand for new users
    \item Collaboration: Docs as a shared knowledge source
  \end{itemize}
\end{frame}

\subsection{Sphinx}
\begin{frame}[fragile]{
  What is Sphinx?
  \hfill
  \doc{https://www.sphinx-doc.org}{Sphinx}}
  \begin{itemize}
    \setlength{\itemsep}{1em}
    \item Open-source, extensible documentation generator written in Python
    \item Multiple output formats: \texttt{HTML}, \LaTeX{} (for \texttt{PDF}), \texttt{ePub}, and more\dots
    \item Creates cross-references within your project and across different projects
    \item Allows documentation using a mark-up language (\reST)
    \item Supports various docstring formats (some through extensions)
  \end{itemize}

  \vspace{1cm}
  There are also alternatives to Sphinx, like \emph{MkDocs} and \emph{pdoc}, but Sphinx can be considered the industry standard for Python docs.
\end{frame}


\begin{frame}[fragile]{Installation}
  Sphinx can be installed via standard package managers:
  \begin{itemize}
    \setlength{\itemsep}{1em}
    \item Installing from PyPI using \texttt{pip}:
    \begin{minted}{shell-session}
      $ pip install -U sphinx
    \end{minted}
    \item Conda/Mamba:
    \begin{minted}{shell-session}
      $ mamba install sphinx
    \end{minted}
    \begin{minted}{shell-session}
      $ conda install -c conda-forge sphinx
    \end{minted}

    \item Debian/Ubuntu using \texttt{apt}:
    \begin{minted}{shell-session}
      # apt install python3-sphinx
    \end{minted}

  \item Fedora Linux, RHEL, CentOS using \texttt{yum} or \texttt{dnf}:
    \begin{minted}{shell-session}
      # yum install python-sphinx
      # dnf install python-sphinx
    \end{minted}

    \item Homebrew:
      \begin{minted}{shell-session}
        $ brew install sphinx-doc
      \end{minted}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Getting Started}
  \begin{minted}[escapeinside=||]{shell-session}
    $ sphinx-quickstart docs
    |\textcolor{cmauve}{> Separate source and build directories (y/n) [n]:}| y
    |\textcolor{cmauve}{> Project name:}| ...
    |\textcolor{cmauve}{> Author name(s):}| ...
    |\textcolor{cmauve}{> Project release []:}| ...
    |\textcolor{cmauve}{> Project language [en]:}| ...
  \end{minted}

  \begin{center}
  \pause
  \begin{minipage}{.45\textwidth}
  \adjustbox{max height=5.5cm}{%
    \begin{forest}
      for tree={dir tree}
      [docs, opened
        [build, closed]
        [source, opened
          [\_static, closed]
          [\_templates, closed]
          [conf.py, pythonfile]
          [index.rst, textfile]
        ]
        [make.bat, batchfile]
        [Makefile, makefile]
      ]
    \end{forest}
  }
  \end{minipage}
  \hfill
  \pause
  \begin{minipage}{.45\textwidth}
    \adjustbox{max height=5.5cm}{%
      \begin{forest}
        for tree={dir tree}
        [docs, opened
          [\_build, closed]
          [\_static, closed]
          [\_templates, closed]
          [conf.py, pythonfile]
          [index.rst, textfile]
          [make.bat, batchfile]
          [Makefile, makefile]
        ]
      \end{forest}
    }
  \end{minipage}
  \end{center}
\end{frame}
{
\setbeamercolor{description item}{fg=vertexDarkGrey}
\begin{frame}[fragile]{Breakdown of the Generated Structure}
  \begin{description}[labelwidth=\widthof{\faFolderOpen \texttt{\_templates}}]
    \setlength{\itemindent}{-4em}
    \item [\textcolor{dircolor}{\faFolderOpen} \texttt{build}:] Output directory for the docs.
    \item [\textcolor{dircolor}{\faFolderOpen} \texttt{\_static}:] Directory for static elements such as images, icons, or logos.
    \item [\textcolor{dircolor}{\faFolderOpen} \texttt{\_templates}:] Used to store \href{https://jinja.palletsprojects.com/en/stable/}{\texttt{Jinja}}
      templates for HTML page generation. %Also used by some Sphinx extensions.
    \item [\textcolor{vertexDarkRed}{\faFile*} \texttt{index.rst}:] Root document; contains the root of the table of contents tree.
      % Effectively your landing page in the HTML version.
    \item [\textcolor{vertexDarkRed}{\faPython} \texttt{conf.py}:] Main configuration file written in Python.
  \end{description}
\end{frame}
}

\begin{frame}[fragile]{Let's Build Our Docs}
  We will use the \texttt{Makefile} generated by \mintinline{shell-session}+sphinx-quickstart+ to build any format:
  \begin{minted}{shell-session}
    $ make <format>
  \end{minted}
  So, for the HTML version:
  \begin{minted}{shell-session}
    $ make html
  \end{minted}
  This will generate the HTML files for our docs inside the \texttt{build} directory.
  We can view the docs locally by running a Python HTTP server (in this case from inside the \texttt{docs} directory):
  \begin{minted}{shell-session}
    $ python -m http.server -d build/html [port]
  \end{minted}

  \begin{block}{Note}
    \mintinline{shell-session}+[port]+ is optional, see \mintinline{shell-session}+python -m http.server --help+.
  \end{block}
\end{frame}


\begin{frame}[fragile]{Preview}
\end{frame}

\begin{frame}[fragile]{Setting Up \texttt{conf.py}}
  The \texttt{conf.py} file generated by Sphinx should look something like this:
  \begin{minted}{python}
    # -- Project information ------------------------
    project = 'pyopp'
    copyright = '2025, Author'
    author = 'Author'
    release = 'v0.1'

    # -- General configuration ----------------------
    extensions = []

    templates_path = ['_templates']
    exclude_patterns = []

    # -- Options for HTML output --------------------
    html_theme = 'alabaster'
    html_static_path = ['_static']
  \end{minted}
\end{frame}

\begin{frame}[fragile]{Setting Up \texttt{conf.py} | Project Information}
  When using a \texttt{pyproject.toml} file for our project, we automatically get the metadata
  from that file using \texttt{tomli} or \texttt{tomllib} (Python $\geqslant$ \texttt{3.11}):
  {
  \footnotesize
  \begin{minted}{python}
    #!/usr/bin/env python3
    import datetime
    import sys
    from pathlib import Path

    import pyvisgen

    if sys.version_info < (3, 11):
        import tomli as tomllib
    else:
        import tomllib

    pyproject_path = Path(__file__).parent.parent.parent / "pyproject.toml"
    pyproject = tomllib.loads(pyproject_path.read_text())

    project = pyproject["project"]["name"]
    author = pyproject["project"]["authors"][0]["name"]
    copyright = "{}.  Last updated {}".format(
        author, datetime.datetime.now().strftime("%d %b %Y %H:%M")
    )
    python_requires = pyproject["project"]["requires-python"]
  \end{minted}
  }
\end{frame}


\begin{frame}[fragile]{Setting Up \texttt{conf.py} | General Configuration}
  Sphinx extensions add functionality and customization. The following extensions
  are some of the extensions we always use in our docs:
  {
  \footnotesize
  \begin{minted}{python}
    extensions = [
        "sphinx.ext.autodoc",                 # Imports modules and pulls in documentation from docstrings
        "sphinx.ext.intersphinx",             # Cross-references to other projects
        "sphinx.ext.coverage",                # Collects doc coverage stats
        "sphinx.ext.viewcode",                # Links to highlighted source code (i.e. "[source]" button)
        "sphinx_automodapi.automodapi",                    # Automatically generates module documentation
        "sphinx_automodapi.smart_resolver",                # Helps resolving some imports
        "numpydoc",                                        # Support for the NumPy docstring format
        "IPython.sphinxext.ipython_console_highlighting",  # Syntax highlighting of ipython prompts
        "sphinx_copybutton",                               # Adds a copybutton to code blocks
    ]

    # gets rid of some errors during build
    numpydoc_show_class_members = False
    numpydoc_class_members_toctree = False

    intersphinx_mapping = {
       "numpy": ("https://numpy.org/doc/stable", None),
       ...
    }

    suppress_warnings = ["intersphinx.external"]  # sometimes necessary

    templates_path = ["_templates"]
    exclude_patterns = ["build", "Thumbs.db", ".DS_Store", "changes", "*.log"]

    source_suffix = ".rst"  # Set .rst files as source files for docs
    master_doc = "index"    # index.rst as root file
  \end{minted}
  }
\end{frame}


\begin{frame}[fragile]{Setting Up \texttt{conf.py} | General Configuration}
    Some extensions are external and need to be installed separately in your environment:
    \begin{minted}{shell-session}
      $ mamba install sphinx-automodapi numpydoc pydata-sphinx-theme sphinx-copybutton
    \end{minted}
    or with \texttt{pip}
    \begin{minted}{shell-session}
      $ pip install sphinx-automodapi numpydoc pydata-sphinx-theme sphinx-copybutton
    \end{minted}
\end{frame}


\begin{frame}[fragile]{Setting Up \texttt{conf.py} | HTML And Theme Options}
  HTML options set the look of your docs. The Sphinx community has created a variety of
  themes you can choose from.
  {
  \footnotesize
  \begin{minted}{python}
    html_theme = "pydata_sphinx_theme"            # Modern, widely used theme
    html_static_path = ["_static"]

    html_file_suffix = ".html"

    html_css_files = ["custom.css"]               # Custom CSS settings like colors or fonts

    html_favicon = "_static/favicon/favicon.ico"  # Icon file for browser tabs

    html_theme_options = {...}                    # Depends on the theme

    html_title = f"{project}"                     # e.g. your project name
    htmlhelp_basename = project + "docs"
  \end{minted}
  }
\end{frame}




\begin{frame}[fragile]{Filling the Docs With Some API References}
  We will create the API references (semi-)automatically in a few steps:
  \begin{columns}[onlytextwidth]
    \begin{column}{0.48\textwidth}
      \begin{enumerate}
        \item <1-> Copy the structure of your actual package
        \item <2-> Populate every subdirectory with a \texttt{index.rst}
        \item <3-> Create separate \texttt{.rst} files for every submodule
      \end{enumerate}
      \vspace{0.25cm}
      \begin{center}
        \adjustbox{max height=5cm}{%
          \begin{forest}
            for tree={dir tree}
            [package, opened
              [module1, opened
                [\_\_init\_\_.py, pythonfile]
                [submodule\_a.py, pythonfile]
                [submodule\_b.py, pythonfile]
              ]
              [module2, opened
                [\_\_init\_\_.py, pythonfile]
                [submodule\_c.py, pythonfile]
              ]
              [\_\_init\_\_.py, pythonfile]
            ]
          \end{forest}
        }
      \end{center}
    \end{column}
    \begin{column}{0.48\textwidth}
      \begin{center}
        % \adjustbox{max height=5cm}{%
          \begin{forest}
            for tree={dir tree}
            [docs, opened
              [api-reference, opened
                [module1, opened
                  [index.rst, textfile, visible on=<2->]
                  [submodule\_a.rst, textfile, visible on=<3->]
                  [submodule\_b.rst, textfile, visible on=<3->]
                ]
                [module2, opened
                  [index.rst, textfile, visible on=<2->]
                  [submodule\_c.rst, textfile, visible on=<3->]
                ]
                [index.rst, textfile, visible on=<2->]
              ]
              [...]
            ]
          \end{forest}
        % }
      \end{center}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Filling the Docs With Some API References}
  For now, the API reference will still be empty. We have to fill in
  the \texttt{index.rst} files to change that. Starting with
  \texttt{api-reference/index.rst}:\\[1em]

  \begin{columns}[onlytextwidth]
    \begin{column}{0.38\textwidth}
      \begin{block}{Code}
      \begin{minted}{rst}
        .. _api-reference:

        *************
        API Reference
        *************

        .. toctree::
          :maxdepth: 1
          :glob:

          */index
      \end{minted}
      \end{block}
    \end{column}
    \hfill
    \begin{column}{0.58\textwidth}
      We add\dots
      \begin{enumerate}
        \setlength{\itemsep}{1.5em}
        \item A tag \texttt{.. \_api-reference:} to the file so we can reference it if necessary
        \item A title, \eg, \enquote{API Reference}
        \item The table of contents with the \texttt{.. toctree::} directive
          \begin{itemize}
            \item And add only \texttt{index.rst} files from the subdirectories to the TOC
          \end{itemize}
      \end{enumerate}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Filling the Docs With Some API References}

  \begin{columns}[onlytextwidth]
    \begin{column}{0.52\textwidth}
      \begin{block}{Code}
      \scriptsize
      \begin{minted}{rst}
        .. _module1:

        ********************************
        Module1 (:mod:`project.module1`)
        ********************************

        .. currentmodule:: project.module1


        Introduction
        ============

        :mod:`project.module1` contains useful methods and classes.


        Submodules
        ==========

        .. toctree::
          :maxdepth: 1
          :glob:

          submodule_a
          submodule_b


        Reference/API
        =============

        .. automodapi:: project.module1
            :no-inheritance-diagram:
      \end{minted}
      \end{block}
    \end{column}
    \hfill
    \begin{column}{0.46\textwidth}
      Now, we do the same for the \texttt{index.rst} files in the module directories:\\[1em]
      We add\dots
      \begin{enumerate}
        \setlength{\itemsep}{1.5em}
        \item A tag and module title
        \item The \texttt{.. currentmodule::} directive to let Sphinx know that
          classes and functions documented from here on are in the given module
        \item (optional) Some introduction to the module
        \item The table of contents for the submodules of the module
        \item The \texttt{.. automodapi::} directive for the current module to get a list of
          classes and functions
      \end{enumerate}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Filling the Docs With Some API References}
  Finally, we write the submodule \texttt{.rst} files:

  \begin{columns}[onlytextwidth]
    \begin{column}{0.5\textwidth}
      \begin{block}{Code}
      \footnotesize
      \begin{minted}{rst}
        .. _data:

        ************************************************
        submodule_a (:mod:`project.module1.submodule_a`)
        ************************************************

        .. currentmodule:: project.module1.submodule_a

        Submodule of :mod:`project.module1`.


        Reference/API
        =============

        .. automodapi:: project.module1.submodule_a
            :inherited-members:
      \end{minted}
      \end{block}
    \end{column}
    \hfill
    \begin{column}{0.46\textwidth}
      We add\dots
      \begin{enumerate}
        \setlength{\itemsep}{1.5em}
        \item A tag, the submodule title, and the\\\texttt{.. currentmodule::} directive
        \item (optional) Some introduction to the submodule
        \item The \texttt{.. automodapi::} directive for the current submodule to get a list of
          classes and functions
      \end{enumerate}
    \end{column}
  \end{columns}
\end{frame}


\subsection{reStructuredText (\reST)}

\begin{frame}[fragile]{
    \reST{} Basics
    \hfill
    \doc{https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html}{\reST}
  }
  \begin{itemize}
    \setlength{\itemsep}{1em}
    \item Paragraphs are the fundamental text blocks in \reST, \ie, text chunks at the same
      indentation and separated by blank lines
    \item Inline Markup:
      \begin{CodeExplanation}{0.59}[Code][Output]
        \begin{minted}{rst}
          *text* **text** ``text``
        \end{minted}
      \Explanation
        \textit{text} \textbf{text} \texttt{text}
      \end{CodeExplanation}
    \item Hyperlinks:
      \begin{CodeExplanation}{0.59}[Code][Output]
        \begin{minted}{rst}
          This text contains `a link`_.

          .. _a link: https://erumdatahub.de


          This text contains an
          embedded `link <https://erumdatahub.de>`__.
        \end{minted}
      \Explanation
        This text contains \href{https://erumdatahub.de}{a link}.\\[1em]

        This text contains an embedded \href{https://erumdatahub.de}{link}.
      \end{CodeExplanation}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Tables}
  \begin{itemize}
    \item Basic tables are similar to Markdown tables
    \item Rendering depends on your theme
  \end{itemize}
  \begin{block}{Code}
    \begin{minted}{rst}
      +------------------+------------+----------+
      | Header 1         | Header 2   | Header 3 |
      +==================+============+==========+
      | Column 1, Row 1  | 1.00       | 42       |
      +------------------+------------+----------+
      | Column 1, Row 2  | ...        | ...      |
      +------------------+------------+----------+
    \end{minted}
  \end{block}
  \begin{block}{CSV Tables}
    \begin{minted}{rst}
      .. csv-table:: Table Title
         :header: "Header 1", "Header 2", "Header 3"
         :widths: 15, 10, 10

         "Column 1, Row 1", 1.00, 42
         "Column 1, Row 2", ..., ...
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Lists}
  \begin{block}{Code}
    \begin{minted}{rst}
      * A bulleted list
 
      - This is also a bulleted list.
      - But this one has two items, and this
        item has two lines

      1. A numbered list.
 
      #. Autonumbering is also possible.
      #. This is done using a ``#`` sign.
    \end{minted}
  \end{block}
  \begin{block}{Nested Lists}
    \begin{minted}{rst}
      * A bulleted list.

        * With a nested bulleted list.
        * Nested lists have to be separated by a blank line

      * This continues the parent list.
    \end{minted}
  \end{block}
\end{frame}


\begin{frame}[fragile]{Headings}
  \begin{columns}[t, onlytextwidth]
    \begin{column}{0.33\textwidth}
      \begin{block}{Code}
        \begin{minted}{rst}
          ####
          Part
          ####

          *******
          Chapter
          *******

          Section
          =======

          Subsection
          ----------

          Subsubsection
          ^^^^^^^^^^^^^

          Paragraph
          """""""""
        \end{minted}
      \end{block}
    \end{column}
    \hfill
    \begin{column}{0.66\textwidth}
      \begin{itemize}
        \setlength{\itemsep}{1.5em}
        \item The structure is technically determined by order of occurance
        \begin{itemize}
          \item \textbf{But}: For better readability stick to the same order throughout your docs, \eg, the one shown here (recommended)
        \end{itemize}
        \item While overlines are optional, they are encouraged for parts and chapters
        \item Any of the following symbols are valid for over- and underlines:\\
          \textcolor{vertexDarkRed}{\texttt{\#} \texttt{*} \texttt{=} \texttt{-} \texttt{\textasciicircum} \texttt{"} \texttt{+} \texttt{\_} \texttt{\textasciitilde}}
          \mintinline{shell-session}{` . , : ; ' ! ? & $ %}
          \mintinline{shell-session}+( ) [ ] { }+\\
          \mintinline{shell-session}+< > @ \ / |+
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{
    Roles, Directives, and Field Lists
    \hfill
    \doc{https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html}{Roles}
    \doc{https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html}{Directives}
    \doc{https://www.sphinx-doc.org/en/master/usage/restructuredtext/field-lists.html}{Field Lists}
  }
  \begin{block}{Roles}
    Roles are \textbf{inline} pieces of explicit markup that are understood by Sphinx.
    The syntax is:
    \begin{center}
      \begin{minted}{rst}
        :rolename:`content`
      \end{minted}
    \end{center}

    Examples:
    \begin{minted}{rst}
      :mod:`package.module1` :code:`foo = 42` :math:`F = m\cdot a`
    \end{minted}
  \end{block}
  \begin{block}{Directives and Field Lists}
    Directives are \textbf{blocks} of explicit markup that are understood by Sphinx.
    The syntax is:
    \begin{center}
      \footnotesize
      \begin{minted}{rst}
        .. directive:: [(optional) elements depending on directive]
           [:(optional) field list:]

           [Body elements of the directive]
      \end{minted}
    \end{center}

    Examples:
    \footnotesize
    \begin{minted}{rst}
      .. image:: picture.png
         :width: 90%
         :alt: A nice picture.

      .. code-block::
         :caption: A code block.

         def func(param: int) -> int: ...
    \end{minted}
  \end{block}

\end{frame}

\subsection{Docstrings}
\begin{frame}[fragile]{Docstrings}
  Most of the documentation work will require you to write docstrings. The three most common
  formats are:
  \begin{itemize}
    \item \reST
    \item Google
    \item \texttt{numpydoc}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{%
    Docstrings | \reST
    \hfill
    \doc{https://sphinx-rtd-tutorial.readthedocs.io/en/latest/docstrings.html}{\reST{} Style}
  }
  \begin{block}{Structure}
    \footnotesize
    \begin{minted}{python}
      """[Summary of your method]

      :param [Parameter name]: [Parameter description]
      :type [Parameter name]: [Parameter type](, optional)
      :returns: [Return description]
      :rtype: [Return type]
      :raises [Exception class]: [Exception description]
      """
    \end{minted}
  \end{block}
  \begin{block}{Example}
    \footnotesize
    \begin{minted}{python}
      """This is a reST-style docstring.

      :param param1: First parameter.
      :type param1: float
      :param param2: Second parameter, defaults to None.
      :type param2: str, optional
      :returns: Some return value.
      :rtype: int
      :raises ValueError: Raises an exception.
      """
    \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{%
    Docstrings | Google
    \hfill
    \doc{https://google.github.io/styleguide/pyguide.html}{Google Style}
  }
  \begin{block}{Structure}
    \footnotesize
      \begin{minted}{python}
        """[Summary of your method]

        Args:
            [Parameter name] ([Parameter type](, optional)): [Parameter description]

        Returns:
            [Return type]: [Return description]

        Raises:
            [Exception class]: [Exception description]
        """
      \end{minted}
    \end{block}
    \begin{block}{Example}
    \footnotesize
      \begin{minted}{python}
        """This is a Google-style docstring.

        Args:
            param1 (float): First parameter.
            param2 (:obj:`str`, optional): Second parameter. Defaults to None.

        Returns:
            int: Some return value.

        Raises:
            ValueError: Raises an exception.
        """
      \end{minted}
  \end{block}
\end{frame}

\begin{frame}[fragile]{%
    Docstrings | \texttt{numpydoc}
    \hfill
    \doc{https://numpydoc.readthedocs.io/en/latest/format.html}{numpydoc}
  }
  \begin{CodeExplanation}{0.59}[Structure][Example]
    \footnotesize
    \begin{minted}{python}
      """[Summary of your method]

      Parameters
      ----------
      [Parameter name] : [Parameter type](, optional)
          [Parameter description]

      Returns
      -------
      [Return name or type]( : [Return type if name was given])
          [Return description]

      Raises
      ------
      [Exception class]
          [Exception description]
      """
    \end{minted}
    \Explanation
    \footnotesize
    \begin{minted}{python}
      """This is a numpydoc-style docstring.

      Parameters
      ----------
      param1 : float
          First parameter.
      param2 : str, optional
          Second parameter. Default: None

      Returns
      -------
      int
          Some return value.

      Raises
      ------
      ValueError
          Raises an exception.
      """
    \end{minted}
  \end{CodeExplanation}
\end{frame}

\begin{frame}[fragile]{
    Type Hinting
    \hfill
    \doc{https://docs.python.org/3/library/typing.html}{\texttt{typing}}
  }
  \begin{itemize}
    \setlength{\itemsep}{1.5em}
    \item Type hinting is the practice of declaring types for variables using a colon \texttt{:}
  after the variable name:
  \begin{minted}{python}
    foo: int = 1
    bar: str = "pyopp"
    baz: np.ndarray = np.array([...])
  \end{minted}

  \item Usually, type hinting is only applied to function definitions:
  \begin{minted}{python}
    def func(param1: int, param2: int=42) -> int:
        res = param1 + param2
        return res
  \end{minted}

  \item Type hinting offers\dots
  \begin{itemize}
    \item Improved code readability
    \item IDE and linting support, \eg{}, through code completion
  \end{itemize}
  But: It is \textbf{not} enforced at runtime and one has to consider dynamic types.
  \end{itemize}
\end{frame}
